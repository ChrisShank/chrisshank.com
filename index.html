<!DOCTYPE html>
<html lang="en">
  <head popover="manual">
    <title>Chris Shank</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="Chris Shank's notes." />
    <meta name="author" content="Chris Shank" />
    <meta property="og:site_name" content="Chris Shank's Notes" />

    <!-- Light and dark mode icon -->
    <link
      rel="icon"
      type="image/svg+xml"
      sizes="any"
      href="data:image/svg+xml,%3Csvg height='128' width='128' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cstyle%3E text %7B fill: %23000000; %7D @media (prefers-color-scheme: dark) %7B text %7B fill: %23ffffff; %7D %7D %3C/style%3E%3Ctext y='.9em' font-size='90'%3E𝕮%3C/text%3E%3C/svg%3E"
    />

<style id="main.css" editing>@font-face {
  font-family: 'Recursive';
  font-display: swap;
  src: url('./Recursive.woff2') format('woff2');
}

/* For now let's externalize this font instead of inlining it. */
/* https://blog.glyphdrawing.club/font-with-built-in-syntax-highlighting/ */
@font-face {
  font-family: 'Monaspace-Krypton';
  font-display: swap;
  src: url('./Monaspace-Krypton.woff2') format('woff2');
}

* {
  box-sizing: border-box;
}

html {
  font-family: 'Recursive', sans-serif;
  font-optical-sizing: auto;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-style: normal;
  font-variation-settings:
    'slnt' 0,
    'CASL' 0.5,
    'CRSV' 0.5,
    'MONO' 0;
}

body {
  margin: auto;
  max-width: 75ch;
}

main {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

wiki-note {
  display: block;
  border: solid 1px rgba(0, 0, 0, 0.5);
  border-radius: 5px;
  padding: 1rem;
}

pre:has(code) {
  background: black;
  border-radius: 5px;
  padding: 1rem;
  
  code {
    font-family: 'Monaspace-Krypton', monospace;
    font-feature-settings: 'colr', 'calt';
    color: #f1f1f1;
    font-size: 0.8rem;
    font-weight: bold;
    white-space: pre;
  }
}

/* All inline code blocks */
*:not(pre) > code {
  background-color: #656c7633;
  border-radius: 5px;
  font-family: 'Recursive', monospace;
  font-size: 75%;
  font-variation-settings:
    'slnt' 0,
    'CASL' 0,
    'CRSV' 0,
    'MONO' 1;
  padding: .2em .4em;
  white-space: break-spaces;
}

source-actions {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  display: flex;
  gap: 0.5rem;
  align-items: center;
  padding: 0.5rem;
  position: fixed;
  bottom: 0.25rem;
  right: 0.25rem;

  input {
    margin-top: 0;
    margin-bottom: 0;
  }
}
</style>

<style id="editor.css">/* Be careful editing the styles of the editor itself, it could visually break the editor. */
head {
  &:popover-open {
    /* override popover styles */
    background: rgba(0, 0, 0, 0.85);
    inset: 3rem;
    margin: 0;
    padding: 1rem;
    width: unset;
    height: unset;
    overflow: hidden;
    border: none;

    border-radius: 5px;
    box-shadow: 0px 1px 1px rgba(3, 7, 18, 0.02), 0px 5px 4px rgba(3, 7, 18, 0.03), 0px 12px 9px rgba(3, 7, 18, 0.05),
      0px 20px 15px rgba(3, 7, 18, 0.06), 0px 32px 24px rgba(3, 7, 18, 0.08);
    display: flex;
    flex-wrap: no-wrap;
    align-items: start;
    gap: 0.5rem;
    overflow-x: scroll;
  }

  :is(script, style):not([src]) {
    color: transparent;
    display: block;
    font-size: 0;
    
    &::after {
      background: black;
      border-radius: 5px;
      color: #f1f1f1;
      content: attr(id);
      display: block;
      font-size: 0.9rem;
      font-weight: bold;
      padding: 0.5rem;
      white-space: pre;
      font-variation-settings:
        'slnt' 0,
        'CASL' 0,
        'CRSV' 0.5,
        'MONO' 1;
    }

    &[editing]::after {
      outline: solid 2px white;
    }
  }

  script:not([src]):not([type])::after {
    content: attr(id) ' (inline)';
  }

  script[type='importmap']::after {
    content: attr(id) ' (importmap)';
  }

  script[type='hash-module']::after {
    content: '#' attr(id);
  }

  textarea {
    background: transparent;
    border: none;
    color: #f1f1f1;
    font-size: 0.9rem;
    font-family: 'Monaspace-Krypton', monospace;
    font-feature-settings: 'colr', 'calt';
    inset: 0;
    padding: 4rem 0.5rem 0.5rem;
    position: absolute;
    min-width: 0;
    resize: none;
    outline: none;
    overflow-x: scroll;
    z-index: -1;
  }
}
</style>

<script type="importmap" id="dependencies.json">{
  "imports": {
    "idb-keyval": "https://unpkg.com/idb-keyval@5.0.2/dist/esm/index.js"
  }
}
</script>

<script type="hash-module" id="save">
// Set up file saving using the File System Access API (Chromium only) and if it's not available fallback to anchor downloads.
const ID = 'selfContainedFile';

window.saveSelf = async function saveSelf(promptNewFile = false) {
  window.dispatchEvent(new Event('before-save'));

  const suggestedName = document.title + '.html';
  const content = '<!doctype html>\n' + document.documentElement.outerHTML;

  if ('showSaveFilePicker' in window) {
    let fileHandle = await get(ID);

    if (promptNewFile || fileHandle === undefined) {
      fileHandle = await window.showSaveFilePicker({
        id: ID,
        suggestedName,
        types: [{ accept: { 'text/plain': ['.html'], 'text/html': ['.html'] } }],
      });
      await set(ID, fileHandle);
    }

    const writer = await fileHandle.createWritable();
    await writer.write(content);
    await writer.close();
  } else {
    const blob = new Blob([content], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = suggestedName;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  }

  window.dispatchEvent(new Event('after-save'));
}
</script>

<script type="hash-module" id="editor.js">import { get, set } from 'idb-keyval';
let activeSource = document.head.querySelector('[editing]');

let reload = false;

// TODO: implement MutationObserver
let unsavedChanges = false;

const textarea = document.createElement('textarea');
document.head.appendChild(textarea);

if (document.head.hasAttribute('open')) {
  document.head.showPopover();
  textarea.value = activeSource.textContent;
}

// Prompt that there are unsaved changes
window.addEventListener("beforeunload", (e) => {
  if (unsavedChanges) {
    event.preventDefault();
    event.returnValue = true;
  }
});

window.addEventListener('before-save', () => {
  // remove textarea before saving since it will be moved to the body on document load.
  textarea.remove();
})

window.addEventListener('after-save', () => {
  unsavedChanges = true;

  if (reload && window.reloadOnSave.checked) {
    location.reload();
    return;
  }

  reload = false;

  // Append the textarea back after we are done saving.
  document.head.appendChild(textarea);
})

// If a script changes we need to reload the page to apply those changes
document.head.addEventListener('input', (e) => {
  if (e.target.matches('script')) {
    reload = true;
  }
});

// When a source tab is clicked open it up in textarea
document.head.addEventListener('click', (event) => {
  if (event.target.matches(':is(script, style):not([src][editing])')) {
    activeSource?.removeAttribute('editing');
    activeSource.textContent = textarea.value;
    activeSource = event.target;
    activeSource.setAttribute('editing', '')
    textarea.value = activeSource.textContent;
  }
});

// Override default tab behavior to insert tabs instead of change keyboard focus
document.head.addEventListener('keydown', (event) => {
  if (event.key === 'Tab') {
    event.preventDefault();
    document.execCommand('insertHTML', false, '&nbsp;&nbsp;')
  }
})

// Emulate popover="auto" without losing focus
document.documentElement.addEventListener("click",(e) => {
  if(document.head.matches(':popover-open') && e.target !== window.editSource && e.target.closest('head') === null) {
    document.head.hidePopover();
  }
});

document.head.addEventListener('beforetoggle', (event) => {
  // In case the active source was updated while the popover was closed.
  if (event.newState === "open" && activeSource) {
    document.head.setAttribute('open', '');
    textarea.value = activeSource.textContent;
  } else {
    document.head.removeAttribute('open');
    if (activeSource) {
      activeSource.textContent = textarea.value;
    }
  }
});
</script>

<script type="hash-module" id="base-element.js">
export class BaseElement extends HTMLElement {
  static tagName = '';

  static define() {
    customElements.define(this.tagName, this);
  }
}
</script>

<script type="hash-module" id="wiki-note.js">
import {BaseElement} from '#base-element.js';

export class WikiNote extends BaseElement {
  static tagName = 'wiki-note';

  get id() {
    return super.id;
  }

  set id(value) {
    super.id = value;

    const heading = this.querySelector('h2');
    if (heading) {
      heading.textContent ??= value;
    }
  }

  get backlinks() {
    return Array.from(
      document.querySelectorAll(`wiki-note:has(a[href="#${this.id}"])`)
    )
  }
}
</script>

<script type="hash-module" id="main.js">import "#editor.js";
import { WikiNote } from '#wiki-note.js';

WikiNote.define();</script>

<script id="boot-loader.js">// The boot loader initializes a self-contained JS module system, called hash modules.
// Hash modules are scripts of `type="hash-module"` and have an `id` attribute.
// They can refer to each other using their ids like `import foo from '#foo'`.
// The execution timing of this script is important.
//   - all hash modules should be defined before this script
//   - this script should not be a module so it runs synchronously.

const imports = {};

document.querySelectorAll('script[type=hash-module]').forEach((module) => {
  imports['#' + module.id] = URL.createObjectURL(new Blob([module.text], { type: 'application/javascript' }));
});

const importmap = document.createElement('script');
importmap.type = 'importmap';
importmap.text = JSON.stringify({ imports }, null, 2);
document.head.appendChild(importmap);
importmap.remove();

const mainScript = document.createElement('script');
mainScript.type = 'module';
mainScript.text = 'import "#main.js"';
document.head.appendChild(mainScript);
mainScript.remove();
</script>
  </head>

  <body>
    <source-actions>
      <button onclick="saveSelf()">Save</button>
      <button onclick="saveSelf(true)">Save As</button>
      <button id="editSource" onclick="document.head.togglePopover()">Edit Source</button>
      <label><input id="reloadOnSave" type="checkbox" checked="" />Reload as Save</label>
    </source-actions>

    <header>
      <h1>
        <a href="chrisshank.com">Chris Shank</a>
      </h1>
    </header>

    <main>
      <wiki-note id="About Me">
        <h2>About Me</h2>
  
        <p>Hi, I'm Chris! ✌🏻</p>
        <p>
          I explore alternative branches of computing that are communal, prosocial and decorporatized. I'm particularly interested in how we
          can nudge the web in this direction.
        </p>
        <p>
          I'm an independent researcher, which means my <em>open</em> research is directly funded by people like you! Your support means
          everything, so check out <a href="https://github.com/sponsors/ChrisShank/">sponsorship page</a> to get inside access to what I'm
          exploring.
        </p>
  
        <ul>
          <li><a href="https://github.com/ChrisShank">Github</a></li>
          <li><a href="https://bsky.app/profile/chrisshank.com">Bluesky</a></li>
        </ul>
      </wiki-note>

      <wiki-note id="Web page as a REPL">
        <h2>Web page as a REPL</h2>
        <p>Spurred by <a href="https://x.com/rsnous/status/1907964027520573949">Omar Rizwan's tweet</a> about using the browser as a REPL to build an we application from the <code>about:blank</code> page, I started thinking about what it would look like for a website to let you directly modify and persist it's source. This can be a tricky thing to do for a traditional web page. Of course you can pop open the dev tools on any website, change some styles, update some DOM, but there is no good way to persist the changes you made. And even if you were able to, those changes could clash with the way that webpage was architected (e.g. React, etc). The core tension here is the web's single-origin security really dictates that web page was never yours to change, there's a reason we call it “view source”. Another challenge is how do you modify a webpage that is loading tens or even hundreds of separate files.
          Luckily there's a lot of prior art about alternative approaches to this called “self-contained HTML pages” or “self-modifying HTML pages. My first encounter was Cristobal's <a href="https://cristobal.space/note">self-modify HTML notes</a>. I later learned this is how <a href="https://tiddlywiki.com/">Tiddly wiki</a> has been working for decades. At LIVE 24' I saw Gilad Bracha present about the self-contained environment called  <a href="https://www.youtube.com/watch?v=zEz3ekrvgF8">Ampleforth</a>. Tom Larkworthy has recently been working on a self-contained reactive notebook called <a href="https://github.com/tomlarkworthy/lopecode">LopeCode</a>.<br />
          It's probably worth defining that a self-contained HTML file is once that contains all of it's source, no additional networks requests to work. This gives you ownership (and credible exits), forking, and local-first editing. A self-modifying HTML file is one that lets you make change and update itself. Usually this is done directly in the UI, occasionally by popping open in the dev tools. From what I can tell the focus is usually on modify the content of the page, not necessarily the source code.
          I even spent a little bit of time trying figure out how to make my website a self-contained HTML file, but immediately ran into wanting some kind of JS module system to help organize and unfortunately there is no standard that enables that. That was until I <a href="">peeped into Lopecode</a> and realized that Tom had cracked it. It's quite simple when you pull it out. It takes advantage of three things; the fact that script tags don't execute when they have a non-standard <code>type</code> attribute, <a href="">importmaps</a>, and <a href="">Blob URLs</a>. So first we need a new type of <code>script</code> tag, let's call it <code>hash-module</code> and we need to give it an <code>id</code> so other modules can reference it. Here's an example:</p>
        <pre><code class="language-html">&lt;script type=&quot;hash-module&quot; id=&quot;sum&quot;&gt;
  export const sum = (a, b) =&gt; a + b;
&lt;/script&gt;

&lt;script type=&quot;hash-module&quot; id=&quot;main&quot;&gt;
  import { sum } from '#sum';
  console.log(sum(1, 2));
&lt;/script&gt;</code></pre>
        <details>
          <summary>Why do I call it a hash module?</summary>
          <p>Well these modules are referring to each other by ids in a similar way that URL hashes scroll to the element with that <code>id</code>  on page load. Furthermore, adding a hash in the import statement helps differentiate between hash modules and regular JS modules that exist in separate files.
          As I previously mentioned these <code>script</code> tags aren't executed because browsers don't execute script tags with a non-standard <code>type</code> attribute so we need a process that can boot load them up. Luckily it's a pretty simple process: grab all of the has modules, create a blob URL for each, and create an importmap that maps the <code>id</code> of the module to the Blob URL.</p>
        </details>
        <pre><code class="language-js">const imports = {};

document.querySelectorAll('script[type=hash-module]').forEach((module) =&gt; {
imports['#' + module.id] = URL.createObjectURL(new Blob([module.text], { type: 'application/javascript' }));
});

const importmap = document.createElement('script');
importmap.type = 'importmap';
importmap.text = JSON.stringify({ imports }, null, 2);
document.head.appendChild(importmap);
importmap.remove();
        </code></pre>
        <details>
          <summary>Why immediately add then remove the importmap from the DOM?</summary>
        <p> Well <code>script</code> tags execute immediately after being added to the DOM so nothing changes if they're removed.  It's important in the context of a self-contained HTML file that we don't litter it with things that are transient like this importmap.</p>
        </details>
        <p>It's also worth noting the timing that the boot loader runs is important. We want it to execute after all of the hash-modules are parsed, but before all scripts that import hash modules are executed.</p>
        <p>Now we have a self-contained JS module system with a dozen lines of JavaScript! This</p>
        <a href="#Towards an editable web">Towards an editable web</a>
      </wiki-note>

      <wiki-note id="Towards an editable web">
        <h2>Towards an editable web</h2>
        <p>The web started off as a readonly medium, networked infrastructure to share and read documents. In the mid 90s, browsers started experimenting the ability to “view source”. Gary Ing <a href="https://viewsource.info/">recounts</a> that it started as a “fun way to let people surfing the web to see this code, if they wanted to.” It's honestly a miracle that the idea of view source has rooted itself so deeply into the web given its unprecedented nature and its tensions with corprate interests. But “view source” also highlights the readonly nature into the web, there's a reason that it's not called “edit source”. When you navigate to a web page you are merely a spectator of its content and view source lets you peak into its plumbing, if you happen to be technically savvy enough to understand the source. The browser might have downloaded a copy of a web page that someone else created, but it's not a copy you own because it's not a copy that you can annotate and modify.</p>
        <p>It's worth mentioning that the web has become way more interactive since its conception, but it's a different kind of authorship and ownership than I'm interested in. It's a form of permissionful write. The author of the web page had to write a HTML form, program some JavaScript, or implement Drag and Drop to let you modify <em>their</em> web page. You needed the author's permission in order to do that. And it's usually just the content that you are allowed to edit, not the underlying source code. What would the web could look like if it had a model for permissionless write?</p>
        <p>Well the first challenge is around persistence, web pages are quite transient. The copy of the web page that the browser downloaded is lost when that page is navigated away from or the tab is closed. Even if you could permissionlessly modify a web page that page is still not yours. For the better or worse, to gain ownership of a web page you need to have a local copy stored on <em>your</em> file system.</p>
        <p><a href="https://www.w3.org/WAI/UA/work/wiki/Definition_of_User_Agent">Definition of User Agent - WAI UA Wiki</a>
        <a href="https://www.w3.org/TR/UAAG20/#def-user-agent">User Agent Accessibility Guidelines (UAAG) 2.0</a></p>
      </wiki-note>
  
      <wiki-note id="DOM as a hypergraph">
        <h2>DOM as a hypergraph</h2>
      </wiki-note>
    </main>
  </body>
</html>
